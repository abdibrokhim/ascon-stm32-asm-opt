# Code Optimization for STM32F103/STM32F407 Discovery Boards – Time and Memory Analysis

## Discussion

The findings from this study highlight the pivotal role of optimization in enhancing the efficiency of embedded systems, particularly those operating under stringent resource constraints, such as the STM32F103 and STM32F407 Discovery Boards. By conducting experiments on the Bubble Sort algorithm, the ASCON lightweight cryptographic algorithm, and the GOST 28147-89 cryptographic standard, we demonstrated substantial improvements in both code size and execution time, addressing critical needs in resource-constrained environments like IoT applications.
For the Bubble Sort algorithm, the primary focus was on reducing memory footprint. Techniques such as employing size-optimized libraries (e.g., newlib), removing unused code sections, and adjusting memory allocation strategies resulted in a remarkable reduction in code size from 141,320 bytes to as low as 4,012 bytes when combining optimizations. This significant decrease underscores the effectiveness of these methods in minimizing memory usage, which is essential for embedded systems with limited flash memory. The use of compiler optimization flags, such as -O3, further enhanced these outcomes by enabling advanced optimizations like loop unrolling and function inlining.

In contrast, the optimizations for ASCON and GOST 28147-89 prioritized execution time improvements. For ASCON, strategies including reduced memory accesses and optimized instruction scheduling led to a 39.6% speedup over the original implementation, reducing execution time from 15.63 seconds to 9.44 seconds. Similarly, for GOST 28147-89, optimizations such as using precomputed tables and unrolling all 32 rounds reduced execution time by 49.13%, from 4:49 seconds to 2:29 seconds for 64 bytes. However, these performance gains came with increased memory usage due to larger precomputed tables, illustrating a common trade-off in embedded system optimization where speed improvements may increase memory demands.
Comparing these findings with prior studies, we observe alignment with established research on embedded system optimization. Previous work has demonstrated that compiler optimizations, such as those using -O3 flags, significantly improve execution time for algorithms like Bubble Sort, with one study noting a C implementation outperforming hand-optimized Assembly by 34.01% for an array of 32,768 elements. Our study extends this by showing that similar compiler-driven techniques, combined with memory-focused strategies, can drastically reduce code size, adding a new dimension to the optimization landscape. For cryptographic algorithms, our results corroborate literature suggestions that techniques like loop unrolling and memory alignment are effective for enhancing performance on ARM-based platforms, as seen in ASCON’s design for lightweight cryptography and GOST’s potential for optimization despite its 32-round structure.
Nevertheless, several limitations must be acknowledged. The optimizations were tailored specifically for the STM32F103 and STM32F407 boards, which feature ARM Cortex-M3 and Cortex-M4 processors, respectively. While the techniques are theoretically applicable to other platforms, their effectiveness may vary due to differences in hardware architecture or resource constraints. The observed trade-offs between memory and speed optimizations necessitate careful consideration, as applications with strict memory limits may prioritize different strategies than those requiring high performance. Additionally, the study notes a pending cross-experiment comparison to generalize optimization gains across algorithms, indicating a gap in fully understanding the broader applicability of these findings.

Unexpectedly, some individual optimizations for Bubble Sort, such as O5, O6, and O7, were ineffective or even increased code size, with O6 resulting in 141,344 bytes compared to the baseline of 141,320 bytes. This highlights the importance of context-specific optimization selection and the potential pitfalls of applying generic techniques without thorough evaluation. These findings suggest that developers must carefully profile and benchmark their code to identify the most effective strategies for their specific use case.
Looking ahead, several avenues for future research emerge. Investigating the impact of these optimizations on power consumption is particularly relevant for battery-powered embedded systems, where energy efficiency is a critical concern. Additionally, assessing the security implications of optimized cryptographic implementations is essential to ensure that performance enhancements do not compromise security, especially for algorithms like ASCON and GOST used in secure communications. Exploring hardware-specific features, such as SIMD instructions on the Cortex-M4, could yield further performance gains, as suggested by prior research on instruction-level parallelism. Finally, conducting a comprehensive cross-experiment comparison would help generalize these findings and provide a more robust framework for embedded system optimization.